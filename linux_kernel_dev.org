#+OPTIONS:^:{}
* Chapter 3 Process Management
** The Process
   + 进程简言之就是正在执行的程序和它所占有的资源的总和, 它所占有的资源,
     简单来说有如下:
     1) 打开的文件
     2) 挂起的信号
     3) 内核内部的数据
     4) 处理器的状态
     5) 内存地址(包括内存的映射关系)
     6) 一个或多个线程
     7) 存放全局变量的数据段
   + 线程一般是进程的一部分,但是在Linux系统中不区分进程和线程,对于Linux来说,
     线程只是碰巧恭喜资源的一些进程
   + 现代操作系统提供了两个虚拟:
     - 让所有的process认为自己独享CPU
     - 让所欲的process认为自己独享内存
   + 所有的process都是从fork()开始的, fork()这个函数很特别,从内核中返回两次,一次
     在parent,一次在child.当前的Linux是通过clone()来实现fork()的
   + 在chlid中,fork返回后,一般都是执行新的程序, exec()系列函数负责这个部分
   + 当process结束的适合,会调用exit()函数. 所有调用了exit()的process都要进入
     一个叫做zombie的状态来等待他们的parent调用wait()系列函数来释放他们的资源
** Process Descriptor and the Task Structure
   + 每一个process的信息都写在process descriptor里面(descriptor是一个unix理念,
     基本所有的对象都有一个descriptor), 在Linux里面process descriptor的类型不再
     是一个简单的类型,而是一个struct: struct task_struct
   + 在32位机器上面,这个task_struct有1.7K大小,因为他保存了一个process所占有的所有
     的资源(1打开的文件,2挂起的信号...)
** Allocating the Process Descriptor
   + 为了达到对象重用和缓存着色(Cache Coloring)的目的, Linux使用slab allocator
     来动态的分配task_struct.
   + 每个进程都有一个自己的进程内核栈,原来task_struct是静态分配的,那么就存放在每个
     内核栈的最后面(最不可能被用到的地方, 同时也方便找到).因为2.6以后, task_struct
     是动态分配的,地址都是不定的.所以很自然的我们想到在原来内存栈最后面的地方存放一个
     指针来指向task_struct.后来为了增加信息把这个指针扩充成了一个新的结构体
     task_info(这个结构体第一个成员就是指向task_struct的指针)
   + task_info代码如下:
     #+begin_src c
       struct thread_info {
           struct task_struct      *task;
           struct exec_domain      *exec_domain;
           __u32                   flags;
           __u32                   status;
           __u32                   cpu;
           int                     preempt_count;
           mm_segment_             addr_limit;
           struct restart_block    restart_block;
           void                    *sysenter_return;
           int                     uaccess_err;
       }
     #+end_src
   + 整体示意图如下:
     #+begin_example
                     Process Kernel Stack
              +------------------------------+ -- highest memory address
              |       Start of Stack         |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              +--------------+---------------+ -- stack pointer
              |              |               |
              |              V               |
              |                              |
              |                              |
              |                              |
              |                              |
              +------------------------------+
              |   struct thread_info {       |
              |     struct task_struct *task;|
              |     //.......                |
              |   }                          |
              |                              |
              +------------------------------+ -- lowest memory address
     #+end_example
** Storing the Process Descriptor
   + 每一个进程都是有一个ID来标示的,类型是pid_t为了和老的Unix系统兼容, pid_t通
     常都是int,这也就意味着系统同时最大共存的进程数目是32768
   + 如果希望能有更多的进程共存,那么可以修改/proc/sys/kernel/pid_max
   + 内核中河task_struct直接沟通的情况非常多,那么直接能够得到当前的task_struct
     就变的很必要.
     - 在power pc等寄存器多的系统中,一般当前的task_struct地址就存在r2这个寄存器中.
     - 在x86这种系统中,我们可以用刚才上面讲解的thread_info在进程内核栈最开始这个有
       利的布局,通过当前内核栈开始位置减去内核栈大小就得到了thread_info的位置,然后
       current_thread_info()->task就得到了task_struct的地址.
** Process State
   + task_struct里面有很多重要的变量,比如这个state,它表达了process可能处于的如下
     几种状态:
     - TASK_RUNNING : 正在运行或者在run-queue上等待运行
     - TASK_INTERRUPTIBLE : 程序正在睡眠(也就是被阻塞了),等待某个condition出现
       继而可以重新进入TASK_RUNNING状态.因为是INTERRUPTIBLE,所以proceess也可能
       接受到某个信号而重新进入TASK_RUNNING
     - TASK_UNINTERRUPTIBLE : 和上面的TASK_INTERRUPTIBLE一样,除了无法接受中断
       而唤醒.(我们使用ps命令看到的在state里面显示为D的,就是这种状态的process, 因
       为连信号都无法中断它,所以你发送SIGKILL也是无法杀掉这个进程的.即便有办法杀掉,
       杀掉这样的进程也不合理,因为它可能正在一个很重要的操作中间,而且可能持有一个信
       号量. 使用场景:
       1) 在一个process必须等待而不能被中断的场景
       2) 要等待的context应该会马上到来
     - __TASK_TRACED : 进程正在被其他进程跟踪
     - __TASK_STOPPED : 进程的执行已经被终止:
       1) 要么是收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
       2) 要么是在debug的适合收到任何的信号
   + 这些状态的转换图如下:
     #+begin_example
                                                                                                                                                    
           +----------------------+                                                                                   +----------------------+ 
           |  Existing task calls |                                                                                   |                      | 
           |  fork() to create    |                                                                                   |  Task is termminated | 
           |  a new process       |                                                                                   |                      | 
           |                      |                                                                                   |                      | 
           |                      |                     Scheduler dispatches task to run:                             |                      | 
           |                      |                     schedule() calls context_switch()                             |                      | 
           |                      |            +------------------------------------------------------+               |                      | 
           +-----------+----------+            |                                                      |               +----------------------+ 
                       |                       |                                                      |                            ^           
                       |            +----------+-----------+                             +------------V-----------+                |           
                       |            |                      |                             |                        |                |           
                       | Task forks |  TASK_RUNNING        |                             |  TASK_RUNNING          |  Task exits via|           
                       |            |  (ready but not      |                             |  (running)             |    do_exit     |           
                       +----------->|   running)           |                             |                        +----------------+           
                                    |                      |                             |                        |                            
                                    +----------------------+                             |                        |                            
                                          ^     ^             Task is preempted          +------------+----+------+                            
                                          |     |             by higher priority task                 |    |                                   
                                          |     +-----------------------------------------------------+    |                                   
                                          |                                                                |                                   
                                          |                                                                |                                   
                                          |                                                                |                                   
                                          |                +----------------------------+                  |                                   
                                          |                |                            |                                                      
                                          |                |   TASK_INTERRUPTIBLE       |    Task sleeps on|                                   
                                          |                |            or              |   wait queue for |                                   
                                          |                |   TASK_UNINTERRUPTIBLE     |   a specific event                                   
                                          |                |          (waiting)         |                  |                                   
                                          +----------------+                            <------------------+                                   
                                    Event occurs and task  |                            |                                                      
                                    is woken up and placed |                            |                                                      
                                    vack on the run queu   |                            |                                                      
                                                           +----------------------------+                                                      
     #+end_example
** Manipulating the Current Process State
   + 在Linux中要考虑多核的情况,所以不能直接task->state = state, 需要一个函数来完成
     #+begin_src c
       set_task_state(task, state);
       set_current_state(state);
     #+end_src
** Process Context
   + 所谓"进程上下文"是指的,当process开始运行的时候一般是在用户空间, 而用户空间的功能
     是有限的,它会用到内核的功能,这个时候可以通过:
     1) 系统调用
     2) 触发异常
   + 当我们通过上面的方式进入内核态的时候,内核其实是帮用户态的process在工作,我们就说
     这种工作状态为"进程上下文"(内核代表进程执行)
   + 在进程上下文中, current宏是有效的, 因为内核是知道在帮助哪个用户的process在工作,
     后面讲到的中断上下文(interrupt context), current就没有用了,因为不是为某个
     proces工作
** The Process Family Tree
   + 每个进程都有一个父进程, 而每个进程也会有0到多个子进程.在task_struct里面分别通过
     变量parent 和 child来访问
   + 所有的进程都有一个"跟进程"
     那就是init, 在Linux里面叫init_task,PID==1.
** Process Creation
   + 在类Unix系统中, 进程的创建都很独特: 其他操作系统一般是在新的用户空间创建新
     的进程. 而Unix把这个工作分成了两步:
     1) fork : 创建一个子进程,只有一些参数和父进程不一样(parentID, PID不会继承
	挂起的信号也不会继承)
     2) exec() : 把新的可执行程序导入到地址空间开始执行
** Copy-on-Write:
   + 我们说Unix系统进程创建之所以独特,也就是独特在fork上面,因为传统的fork会吧所有
     的父进程的资源复制一遍给子进程.因为子进程并不需要那么多的资源,而且很可能
     子进程要重启新的炉灶(新的可执行程序),所有的资源都要放弃. 这个时候我们就
     引入了"写时拷贝"
   + 所谓"写时拷贝"就是fork的时候,资源是只读的,父子进程共享地址, 一旦这些资源被
     写入了,那么说明一份新的数据会诞生.那么父子就不能在使用相同的地址了. 这个时候
     就要再复制一份新的数据. 因为很多情况下, fork之后马上是exec(), 所以数据的复
     制从头到尾都没有执行过.
   + fork其实只需要给子进程复制一下page table, 和创建一些新的process descriptor
     里面的变量而已,所以速度要快,这符合Unix快速创建进程的哲学
** Forking
   + Linux的fork==>clone(), clone()通过一些flag来判断父子进程共享哪些资源
   + clone()内部==>do_fork()
   + do_fork()==>copy_process(), 真正的工作在这里执行
     1) 调用dup_task_struct(), 创建如下:
	1. 一个新的内核栈,一般是8K或者4K, 地址是新的和老的不一样
	2. 一个新的thread_info(在内核栈内部), task成员变量一会会指向下面的task_struct
	3. 一个新的task_struct, 内容和父进程的一样(并将thread_info内部的指针地址更改)
     2) 检查一下创建新进程后,当前用户的资源有没有超标
     3) 因为刚才的数据都是复制的,父子的task_struct是一样的,但是为了区分父子,肯定有很多
	属性要不一样:比如一些计数的属性要清零. 但大部分还是一样的.这里主要是属性,不是"写时
	拷贝"的那些数据
     4) 子进程被设置为TASK_UNINTERRUPTIBLE防止它运行
     5) copy_process()==>copy_flag() 更新子进程的flags: 清零PF_SUPERPRIV(表明进程
	是否拥有超级用户权限), 清零PF_FORKNOEXEC(表明还没有调用exec())
     6) copy_process()==>alloc_pid()来赋予一个新的PID
	
   


     
