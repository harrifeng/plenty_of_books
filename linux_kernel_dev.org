#+OPTIONS:^:{}
* Chapter 3 Process Management
** The Process
   + 进程简言之就是正在执行的程序和它所占有的资源的总和, 它所占有的资源,
     简单来说有如下:
     1) 打开的文件
     2) 挂起的信号
     3) 内核内部的数据
     4) 处理器的状态
     5) 内存地址(包括内存的映射关系)
     6) 一个或多个线程
     7) 存放全局变量的数据段
   + 线程一般是进程的一部分,但是在Linux系统中不区分进程和线程,对于Linux来说,
     线程只是碰巧恭喜资源的一些进程
   + 现代操作系统提供了两个虚拟:
     - 让所有的process认为自己独享CPU
     - 让所欲的process认为自己独享内存
   + 所有的process都是从fork()开始的, fork()这个函数很特别,从内核中返回两次,一次
     在parent,一次在child.当前的Linux是通过clone()来实现fork()的
   + 在chlid中,fork返回后,一般都是执行新的程序, exec()系列函数负责这个部分
   + 当process结束的适合,会调用exit()函数. 所有调用了exit()的process都要进入
     一个叫做zombie的状态来等待他们的parent调用wait()系列函数来释放他们的资源
** Process Descriptor and the Task Structure
   + 每一个process的信息都写在process descriptor里面(descriptor是一个unix理念,
     基本所有的对象都有一个descriptor), 在Linux里面process descriptor的类型不再
     是一个简单的类型,而是一个struct: struct task_struct
   + 在32位机器上面,这个task_struct有1.7K大小,因为他保存了一个process所占有的所有
     的资源(1打开的文件,2挂起的信号...)
** Allocating the Process Descriptor
   + 为了达到对象重用和缓存着色(Cache Coloring)的目的, Linux使用slab allocator
     来动态的分配task_struct.
   + 每个进程都有一个自己的进程内核栈,原来task_struct是静态分配的,那么就存放在每个
     内核栈的最后面(最不可能被用到的地方, 同时也方便找到).因为2.6以后, task_struct
     是动态分配的,地址都是不定的.所以很自然的我们想到在原来内存栈最后面的地方存放一个
     指针来指向task_struct.后来为了增加信息把这个指针扩充成了一个新的结构体
     task_info(这个结构体第一个成员就是指向task_struct的指针)
   + task_info代码如下:
     #+begin_src c
       struct thread_info {
           struct task_struct      *task;
           struct exec_domain      *exec_domain;
           __u32                   flags;
           __u32                   status;
           __u32                   cpu;
           int                     preempt_count;
           mm_segment_             addr_limit;
           struct restart_block    restart_block;
           void                    *sysenter_return;
           int                     uaccess_err;
       }
     #+end_src
   + 整体示意图如下:
     #+begin_example
                     Process Kernel Stack
              +------------------------------+ -- highest memory address
              |       Start of Stack         |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              |              |               |
              +--------------+---------------+ -- stack pointer
              |              |               |
              |              V               |
              |                              |
              |                              |
              |                              |
              |                              |
              +------------------------------+
              |   struct thread_info {       |
              |     struct task_struct *task;|
              |     //.......                |
              |   }                          |
              |                              |
              +------------------------------+ -- lowest memory address
     #+end_example
** Storing the Process Descriptor
   + 每一个进程都是有一个ID来标示的,类型是pid_t为了和老的Unix系统兼容, pid_t通
     常都是int,这也就意味着系统同时最大共存的进程数目是32768
   + 如果希望能有更多的进程共存,那么可以修改/proc/sys/kernel/pid_max
   + 内核中河task_struct直接沟通的情况非常多,那么直接能够得到当前的task_struct
     就变的很必要.
     - 在power pc等寄存器多的系统中,一般当前的task_struct地址就存在r2这个寄存器中.
     - 在x86这种系统中,我们可以用刚才上面讲解的thread_info在进程内核栈最开始这个有
       利的布局,通过当前内核栈开始位置减去内核栈大小就得到了thread_info的位置,然后
       current_thread_info()->task就得到了task_struct的地址.
