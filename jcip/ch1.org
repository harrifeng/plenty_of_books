* Chapter 1: Introduction
  + 线程是JAVA无法回避的重要特性，它可以帮助我们把复杂的异步程序变成简单的几行代码
  + 另外，线程是最容易利用多核威力的方法,随着cpu核心数的增加, 提高并发效率就变的
    尤为重要
** A (Very) Brief History of Concurrency
   + 在计算机的原始时代, 是没有操作系统的, 在计算机上一个程序从头跑到尾,而且能动
     用计算机所有的资源.这种系统,不仅仅是写程序麻烦,而且每次只能运行一个程序,对于
     计算机资源来说,是极大的浪费
   + 操作系统的引入,让两个以上的程序同时允许成为了可能:
     - 程序都被操作系统设计成一个进程, 进程之间的资源是操作系统分配的, 相互之间是
       独立的,相互隔离的
     - 如果两个进程之间想相互通信, 那么可以通过以下几种方式:
       1) sockets
       2) signal handlers
       3) shared memory
       4) semaphores
       5) file
   + 操作系统设计成多个程序(运行起来才叫进程)可以同事允许的初衷有以下几点:
     1) 资源的利用: 程序可能会时常需要等待外部的输入输出, 在等待的时候,如果能够做
        一些其他的事情,有助于资源更好的利用
     2) 公平: 多个用户在同时使用一台机器的时候, 都有平等的使用资源的权利, 这种
        平等的实现应该是通过时间片的等额分割,而不是说某个用户的一个程序执行完,然后
        让另外一个用户执行其他程序
     3) 方便:写多个程序,每个简单的功能,然后让多个程序合作,比起写一个"多功能"的
        程序要方便的多
   + 早期的共享时间的系统当中, 每个进程都是一个虚拟的"冯诺依曼计算机":
     - 每个进程都有自己的内存空间, 包括数据和指令(代码)
     - 顺序执行当前的指令, 对于每一个指令来说,永远存在"下一条"指令, 指令的指定
       要么是事先写好的,要么逻辑控制的
     - 通过操作系统指定的一系列的IO原语与外界进行联系
   + 线性的编程模型是自然的而直观的, 因为人类活动就和它很像:每次只做一件事情,
     大部分情况下,顺序执行,举个例子:
     1) 起床
     2) 穿好衣服
     3) 下楼
     4) 打开茶叶盒,放入茶杯茶叶
     5) 查看是否有足够的热水:
     6) if 有足够的热水, 开始泡茶
     7) else 没有足够热水, 开始烧水
   + 上面7)是烧水,在烧水的空间,你可以选择烤面包,或者看报纸. 烤面包机和烧水壶这种
     设备知道自己经常会被"异步使用",所以它们会发出声音来提示使用者
   + 找到"线性"工作和"异步"使用的平衡是一个高效人士的要务,这对程序来说也是一样的
   + 发明进程的几个原因(资源利用, 公平, 方便)也催生出了线程的发明.线程的特点有:
     1) 允许多个程序控制流在一个进程里面同时存在:
     2) 这多个线程共享进程的资源:内存,文件描述符;但是这些线程拥有自己的程序计数器,
        stack,和局部变量
     3) 多个线程在同一时间可以被调度到不同的CPU,而达到共同运行的目的
** Benefits of Threads
   + 如果运用的得当,线程可以减少开发和维护的费用,提高复杂系统的性能.
   + 线程是一种通过把"线性"模式转换成"异步"陌生,来提高效率的方法
   + 线程在GUI应用中开业大幅度的提高用户借口的响应率,在服务器开发中
     可以提高资源的利用率和输出
*** Exploiting Multiple Processors
    + 因为调度的最小单位是线程,所以如果一个程序只有一个线程,那么每次
      它只能运行在一个核上. 如果这个CPU是双核的,那么它放弃了50%的计
      算力,如果是100核,那就是99%...
    + 即便是在单核的CPU上面,多线程也是可以提高效率的,比如一个程序是
      单线程的,那么如果遇到了I/O,操作,那么唯一的线程就得busy waiting
      了. 如果这个程序还有其他线程B,那么可以在线程A等待I/O的空隙里面,
      被调度到,然后运转. (就好像,一边看着报纸,一边等待水开)
*** Simplicity of Modeling
    + 生活中我们有这样的体验, 如果专心做一件事情,比如修复12个bug,通常要比干很多
      乱七八糟的事情(比如,同时修复bug,面试,给自己的下属打分)要来的复杂的多
    + 线程就是这样一种架构: 在程序内部,把不同的事情分开,每种事情写到一块,相互尽量
      不打扰
    + 我们说到的这些好处,通常是各种框架帮我们完成的.框架一般要处理各种细节:相应要求,
      创建线程,处理负载,等等. 而servlet用户完全不用关心这些东西
*** Simplified Handling of Asynchronous Events
    + 作为一个server端程序的话,如果只有一个线程,那么如果和外界connect成功了的话,如果
      当前线程不结束,后续的其他connect也就被block住了,这显然是不对的.
    + 所以server端的一种做法是对每一个connection都设置一个线程
    + 但是由于历史原因, 操作系统对于每个进程能创建的最大线程是有限制的,顶多几百个. 这就
      导致了在Unix系统上面select和poll等系统调用的产生(这些叫做non-blocking I/O,也就
      说没有数据的时候,轮询所有的connection,但是所有connection只有一个线程)
*** More Responsive User Interfaces
    + GUI应用曾经是单线程的(Emacs现在还是...), 也就是说,你要么频繁的应付相应输入操
      作,要么在间接的在"main event loop"里面执行代码. 如果"main event loop"里面
      的代码执行时间过长,那么用户界面就会看起来"卡", 因为只有前面的代码返回以后,用户
      的操作才能进行.
    + 现代的GUI框架,都使用了EDT(event dispatch thread),也就当用户按一个按钮的时候,
      一个相应的thread会运行.
** Risks of Threads
      
      
     

