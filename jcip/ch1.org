* Chapter 1: Introduction
  + 线程是JAVA无法回避的重要特性，它可以帮助我们把复杂的异步程序变成简单的几行代码
  + 另外，线程是最容易利用多核威力的方法,随着cpu核心数的增加, 提高并发效率就变的
    尤为重要
** A (Very) Brief History of Concurrency
   + 在计算机的原始时代, 是没有操作系统的, 在计算机上一个程序从头跑到尾,而且能动
     用计算机所有的资源.这种系统,不仅仅是写程序麻烦,而且每次只能运行一个程序,对于
     计算机资源来说,是极大的浪费
   + 操作系统的引入,让两个以上的程序同时允许成为了可能:
     - 程序都被操作系统设计成一个进程, 进程之间的资源是操作系统分配的, 相互之间是
       独立的,相互隔离的
     - 如果两个进程之间想相互通信, 那么可以通过以下几种方式:
       1) sockets
       2) signal handlers
       3) shared memory
       4) semaphores
       5) file
   + 操作系统设计成多个程序(运行起来才叫进程)可以同事允许的初衷有以下几点:
     1) 资源的利用: 程序可能会时常需要等待外部的输入输出, 在等待的时候,如果能够做
        一些其他的事情,有助于资源更好的利用
     2) 公平: 多个用户在同时使用一台机器的时候, 都有平等的使用资源的权利, 这种
        平等的实现应该是通过时间片的等额分割,而不是说某个用户的一个程序执行完,然后
        让另外一个用户执行其他程序
     3) 方便:写多个程序,每个简单的功能,然后让多个程序合作,比起写一个"多功能"的
        程序要方便的多
   + 早期的共享时间的系统当中, 每个进程都是一个虚拟的"冯诺依曼计算机":
     - 每个进程都有自己的内存空间, 包括数据和指令(代码)
     - 顺序执行当前的指令, 对于每一个指令来说,永远存在"下一条"指令, 指令的指定
       要么是事先写好的,要么逻辑控制的
     - 通过操作系统指定的一系列的IO原语与外界进行联系
   + 线性的编程模型是自然的而直观的, 因为人类活动就和它很像:每次只做一件事情,
     大部分情况下,顺序执行,举个例子:
     1) 起床
     2) 穿好衣服
     3) 下楼
     4) 打开茶叶盒,放入茶杯茶叶
     5) 查看是否有足够的热水:
     6) if 有足够的热水, 开始泡茶
     7) else 没有足够热水, 开始烧水
   + 上面7)是烧水,在烧水的空间,你可以选择烤面包,或者看报纸. 烤面包机和烧水壶这种
     设备知道自己经常会被"异步使用",所以它们会发出声音来提示使用者
   + 找到"线性"工作和"异步"使用的平衡是一个高效人士的要务,这对程序来说也是一样的
   + 发明进程的几个原因(资源利用, 公平, 方便)也催生出了线程的发明.线程的特点有:
     1) 允许多个程序控制流在一个进程里面同时存在:
     2) 这多个线程共享进程的资源:内存,文件描述符;但是这些线程拥有自己的程序计数器,
        stack,和局部变量
     3) 多个线程在同一时间可以被调度到不同的CPU,而达到共同运行的目的
** Benefits of Threads
   + 如果运用的得当,线程可以减少开发和维护的费用,提高复杂系统的性能.
   + 线程是一种通过把"线性"模式转换成"异步"陌生,来提高效率的方法
   + 线程在GUI应用中开业大幅度的提高用户借口的响应率,在服务器开发中
     可以提高资源的利用率和输出
*** Exploiting Multiple Processors
    + 因为调度的最小单位是线程,所以如果一个程序只有一个线程,那么每次
      它只能运行在一个核上. 如果这个CPU是双核的,那么它放弃了50%的计
      算力,如果是100核,那就是99%...
    + 即便是在单核的CPU上面,多线程也是可以提高效率的,比如一个程序是
      单线程的,那么如果遇到了I/O,操作,那么唯一的线程就得busy waiting
      了. 如果这个程序还有其他线程B,那么可以在线程A等待I/O的空隙里面,
      被调度到,然后运转. (就好像,一边看着报纸,一边等待水开)
*** Simplicity of Modeling
    + 生活中我们有这样的体验, 如果专心做一件事情,比如修复12个bug,通常要比干很多
      乱七八糟的事情(比如,同时修复bug,面试,给自己的下属打分)要来的复杂的多
    + 线程就是这样一种架构: 在程序内部,把不同的事情分开,每种事情写到一块,相互尽量
      不打扰
    + 我们说到的这些好处,通常是各种框架帮我们完成的.框架一般要处理各种细节:相应要求,
      创建线程,处理负载,等等. 而servlet用户完全不用关心这些东西
*** Simplified Handling of Asynchronous Events
    + 作为一个server端程序的话,如果只有一个线程,那么如果和外界connect成功了的话,如果
      当前线程不结束,后续的其他connect也就被block住了,这显然是不对的.
    + 所以server端的一种做法是对每一个connection都设置一个线程
    + 但是由于历史原因, 操作系统对于每个进程能创建的最大线程是有限制的,顶多几百个. 这就
      导致了在Unix系统上面select和poll等系统调用的产生(这些叫做non-blocking I/O,也就
      说没有数据的时候,轮询所有的connection,但是所有connection只有一个线程)
*** More Responsive User Interfaces
    + GUI应用曾经是单线程的(Emacs现在还是...), 也就是说,你要么频繁的应付相应输入操
      作,要么在间接的在"main event loop"里面执行代码. 如果"main event loop"里面
      的代码执行时间过长,那么用户界面就会看起来"卡", 因为只有前面的代码返回以后,用户
      的操作才能进行.
    + 现代的GUI框架,都使用了EDT(event dispatch thread),也就当用户按一个按钮的时候,
      一个相应的thread会运行.
** Risks of Threads
   + java内置的对线程的支持是一把双刃剑,这提高了对程序员的要求, 一旦使用多线程,
     就要明白什么是线程安全
*** Safety Hazards
    + 下面这段代码就是线程不安全的
      #+begin_src java
        @NotThreadSafe
        public class UnsafeSequence {
            private int value;
        
            /* Returns a unique value */
            public int getNext() {
                return value++;
            }
        }
      #+end_src
    + 代码线程不安全的原因,是存在下面一种调用过程(非常巧合是吧..对的,就是非常巧,
      也就是说线程的错误不是每次都能重现的)让两个线程调用getNext函数,却得到了同
      样的值(本来这个函数是希望返回值都是独一无二的)
      #+begin_example
        
                +--------+        +--------+        +--------+
         A      | value  +------->| 9+1    +------->+ value  |
                |   9    |        | = 10   |        |  10    |
                +--------+        +--------+        +--------+
        
        
                         +--------+        +--------+        +--------+ 
         B      -------->| value  +------->| 9+1    +------->+ value  | 
                         |   9    |        | = 10   |        |  10    | 
                         +--------+        +--------+        +--------+ 
      #+end_example
    + 因为所有的线程共享内存,而且同时运行, 他们就可能更改其他用户正在使用的数据,
      这本来是一个巨大的方便之处,因为比起其他的进程间通信, 这种使用数据的方式明
      显容易很多. 但是这样也会存在前面说到的你无法知道当前变量是否正被使用. 这个
      时候,就要java提供的同步方法(synchronization mechanism)
      #+begin_src java
        @ThreadSafe
        public class Sequence {
            @GuardedBy("this") private int nextValue;
        
            public synchronized int getNext() {
                return nextValue++;
            }
        }
      #+end_src
    + 如果没有这些同步方法(synchronization mechanism), 编译器,硬件会被赋予相当
      大的自由, 比如会缓存当前变量到寄存器(这个还好,全局可见), 或者缓存变量到某个
      核(processor-local)的cache,这就麻烦了,因为如果线程不在这个核上运行的,根本
      看不到这个cache. 这些操作原本是为了提高程序的运行效率,但是这些操心无法让多个
      线程安全的共享数据
*** Liveness Hazards
    + 前面说的safety意味着"nothing bad ever happens", 而这里的liveness意味着"something
      good eventually happens". 也就是说不关保证没错就行,还要保证我们要做的事情做到!
    + 一个常见不能达到liveness的非多线程例子,就是死循环. 到了多线程阶段,又引入了非常多的这种
      例子:
      - deadlock
      - starvation
      - livelock
*** Performance Hazards
    + 前面说的liveness意味着"something good eventually happens", 这个eventually有时候
      远远不够,因为我们想好事情快快来.也就是说我们要提高多线程程序的效率
    + 效率这个东西涉及到很多:
      - 服务时间
      - 响应率
      - 输出
      - 资源消耗
      - 可扩展性
    + 就像liveness一样,多线程程序的效率的难题不仅仅来自传统的问题,还来自于多线程
      的引入带来的问题
    + 在理想的情况下,利用多核系统带来的都是净收益,但这明显不现实的.线程多的情况下, 
      上下文切换更加频繁, 也意味着更多的资源消耗:
      - 保存上下文
      - CPU调度
      - 使用syn, 无法享受编译器优化, 无法享受缓存
*** Threads are Everywhere
    + 即便你没有显示创建过线程, 框架可能就为你创建过进程,而调用这些进程的代码必
      须线程安全
    + 每一个Java程序都使用了线程
      1) 当JVM开始的时候,会创建houskeeping task 线程负责回收, 还有一个main
         线程来运行main方法.
      2) AWT(Abstract Windows Tookit) 创建了一个线程来管理用户事件
      3) Timer创建了一个线程来管理被拒绝的任务
      4) Servlet创建了线程池,并且调用这些线程里面的方法
    + 如果你是使用了前面的这些工具, 就需要了解线程安全, 因为框架会使用线程来调用
      你的代码, 你的代码会访问到应用的状态.这就要求所有跟这些状态相关的代码线程
      安全

      

      
      
      
     

