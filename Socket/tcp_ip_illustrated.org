#+OPTIONS:^:{}
* Chapter 1: Introduction
** Architectural Principles
*** Packets, Connections, and Datagrams
    + 1960年代之前，网络就是指的电话网络，电话网络的特点是，连接两个节点的整条线
      路是独占的：打电话即便你什么话也不说，也是要收费的。
    + 之后最为重要的发明就是packet switching:一小组(chunk)大概几个Byte的数据独
      立在网络中传递.
    + 从不同的发送方和接收方的不同组(chunk)的数据可以一开始先混合,然后到达终点再分开,
      这种传递方法也叫多路复用(multiplexing). 这极大的提高了网络的利用率
    + 这些独立的组(chunk)数据,还可以经过不同的路径到达目的地.这提高了数据传输的弹性,
      偶然的某些物理线路损坏可能不会导致最后的传输失败.
    + 在路由器收到这些packet的时候，首先是存在自己的内存里面，然后按照先来先服务
      (FIFO)的策略进行转发.而且会根据包的目的地以及计时模式的不同来进行packet的重新
      组装.
    + 统计复用(statistical multiplexing)的缺点就是没有可预见性,就像高速公路上的车
      都可以随意变道(四车道三车道都用来开一个方向),线路有时候会非常繁忙.
    + 统计复用的这些缺点,可以用分时复用或者静态复用来改变,但是分时或者静态复用就意味着
      线路的利用率不够高(高速公路总是两个方向各两条,但很多时候只有一个方向繁忙)
    + 能够继承circuits并且不依靠物理连接的virtual circuits [X.25]在1990年之前非常
      流行,后来被DSL(digital subscriber line)所替代.
    + 在virtual circuits之前,每个路由器都需要保留每一个connection的信息.因为每个packet
      的状态信息非常之少. 这种特质要求在真正传递数据之前,在数据经过的路上,所有的路由器都已经
      做好准备了,而且在数据传输完成之后的清理工作也要做.(都是通过复杂的signal 协议完成的) 
      这就是原来的connection-oriented 网络.
    + 在virtual circuits之前,不管是不是真实的circuits, 它们都是connection-oriented
      的. connection-oriented和connectionless-oriented是网络发展的两个阶段.后面
      我们会看到TCP就是connectionless的网络啦.
    + 后来,packet的模式得到了改变,把源头和目的地都写进了每一个的packet,就叫做datagram了,
      新的packet的组织方式势必会增加每个packet的负担,但是每个路由器里面的connection的信息
      就不用保存了.前面为了提前建立这些个信息的signaling复杂协议就不需要了. 这也就是我们现在
      看到的connectionless协议啦!
    + 需要注意的是,一般情况下协议都会记住不同组(chunk)数据的大小,但是circuit和VC却可能不记录
      这些信息,考虑到我们不会用这些协议了.记住就可以.
*** The End-to-End Argument and Fate Sharing
    + 当我们进行大型的项目(比如操作系统或者协议簇)设计的时候,有一个问题经常会被提
      起,那就是一个特性究竟要在哪里实现.在TCP/IP设计的时候,影响它最深的,就是
      "边缘论(end-to-end argument)"
    + 所谓边缘论, 现在我的理解是那些无法确定放在哪里的特性,肯定是要再end point的
      应用的帮助下,才能完整的正确的实现,所以这些特性是不适合放在协议里面实现的
    + 简言之,底层的协议,可以提供一些便利,但是底层协议无法百分之百的猜对应用的需求,
      在TCP/IP的设计中,底层就只是为应用提供了一些便利,但是重要的特性(错误处理,
      加密,传输确认等)都不是是在底层提供的
    + 边缘论的采用让TCP/IP的设计变成了"傻瓜的网络"(这个网络应该是指的传输中的线路
      包括路由器等)和"智能的系统", 所有的重要函数(错误处理,加密,传输确认)都是在
      end端,也就是应用所在的地方完成的
    + 以边缘论为理论依据,在选择函数在哪里实现这个问题上,又引入了叫做命运共享(Fate 
      sharing)的理论.也就是"一荣俱荣,一损俱损":只有能够破坏一个或者多个end point
      的错误,才能说是破坏了整个通信
    + 命运共享的理论让TCP实现的Virtual connection能够在网络出错了一段时间的情况
      下,依然保持active
*** Error Control and Flow Control
    + 有些情况下,网络上的数据传输会出现错误,也就是bit出现反置, 这是很正常的,最常见
      的原因就有:
      - 硬件出错
      - 辐射
      - 无线网络离开了它的辐射范围
    + 出错以后,就要考虑错误处理了. 在网络上,这叫error control. 由于我们的TCP的设计
      理念(边缘论, 命运共享), 我们会吧error control实现在application里面.
    + 通常情况下,如果错误的bit不多,那么可以引入mathematical codes去改正他们.如果
      出错的地方太多就只有重传了.
    + 在前TCP时代(也就是前面说的circuit-switched等等), 重传是在网络上完成的,这就
      意味着,如果出错,网络上负责给你整理正确,保证end端接受到的都是按照顺序来的, 没有
      错误的. 但是其实end端有时候不喜欢你给我传来这么好的数据, 因为第一他不在乎你吗传
      过来的顺序,因为顺序不对application可以自己整理, 第二传过来这样整齐的数据意味
      着要消耗大量的资源,本来这些资源我是不需要耗费的. 这个例子就是前面边缘论的一个
      反例--在网络上不要做过多的假设, 因为你不知道应用层需要什么.
    + 在TCP时代,替代这种严格按顺序传输的方法叫做best-effort delivery.
    + best-effort delivery不会用太多的精力去确保数据完整正确传输, 错误的发现通常
      是使用校验和, 而且一旦发现错误,整个datagram就直接抛弃,然后重传了.
    + 如果best-effort delivery成功了, 那么发送者的速度会快过接受者. 这个时候,需要
      flow control机制来控制, 这个flow control不是在网络上的,而是在end端应用层里
      面的.
      - 这个和边缘论一致的, 在end端控制速度
      - 这个和命运共享论也是一致的,允许一些数据出错,但是整个的网络连接还是active的.
** Design and Implementation
   + 虽然
      
       
