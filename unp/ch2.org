#+OPTIONS:^:{}
* Chapter 2: The Transport Layer: TCP, UPD, and SCTP
** Introduction
** The Big Picture
   + tcpdump: 是一个直接与datalink沟通的工具, Linux下面其实还有一种socket与
     datalink练习的socket,叫做SOCK_PACKET
   + traceroute: 用了两个sockets: 一个是IP,另一个是ICMP
   + SCTP: 是一个新的网络协议, 可以用IPv4或者IPv6
   + ICMP: 处理错误和控制信息
   + IGMP: 处理multicasting的,已经不怎么用了
   + ARP: IP地址-->MAC地址
   + RARP: MAC地址-->IP地址
   + ICMPv6: 是IPv6里面全面替代ICMPv4, IGMP, 以及ARP
** User Datagram Protocol (UDP)
   + UDP是网络层协议, 不能保证传输的成功,因为它没有保证传输可靠性的方法, 需要
     应用层来保证
   + TCP是一个byte-stream的协议,没有任何边界的概念, 但是UDP有,每个UDP都有长度,
     都会最后传输给对方
   + UDP比较自由,不要维护relation, 它可以发送一个socket给serverA, 然后马上发送
     同一个socket给serverB.
** Transmission Control Protocol (TCP)
   + TCP提供了传输的可靠性: 并不是说用TCP一定能把数据传输给对方, 而是如果能传输数据
     就传输,如果传输不成功,也能报错.
   + TCP还有自己的算法来计算RTT(round-trip time) : 也就是client和server之间的
     传输一次的时间.
   + RTT这个时间是根据当前网络状况和距离而设定的, 并且是不停计算的
   + TCP还会记录序列, 发送的时候可能序列是123, 到达的时候就乱了.接收方的TCP 会把所有
     的TCP segment重新排列(如果有收到重传的segment,也会智能丢弃).
   + TCP还提供流量控制: TCP一直告诉对方自己能够接受多少的数据,这叫advertised window.
   + 这个windows就是接收方能够提供的最大的内存空间.这个数字是不停改变的,刚接受来肯定
     数字变小, 处理一会肯定数字变大. 窗口数字也是可以变成0的,如果接收方处理不过来,当然
     要停止你的传输
   + TCP是全双工的,也就是说,传输是双方向的,并不是叫server就不接受,叫client就不发送.
     当然某个方向的传输停止也是可以自由决定的.
** Stream Control Transmission Protocol (SCTP)
   + SCTP提供了一种client和server之间的association, 之所以叫association而不是叫
     connection是因为:因为connection是两个IP之间的联系,而SCTP是两个系统之间的联系
     不仅仅是两个IP
   + 在消息传递上面,SCTP更像UDP,它把每个记录的长度都传输给了对方
   + SCTP支持两个端之间的多个stream, 其中一个stream如果丢失了一个数据的话,不会影响
     其他stream. 这个和TCP不一样,TCP一个byte丢失就要影响以后的传输(因为要重新排序)
   + SCTP特性还有:单个SCTP端点支持多个IP地址. TCP也可以在其他路由协议的支持下获得
     这种特性
** TCP Connection Establishment and Termination
   + TCP建立连接的时候通常有如下的过程:
     1) 服务器必须首先准备好, 通过socket, bind和listen这三个函数,我们把这三个函数的
        过程叫:被动打开(passive open)
     2) 客户端自然就是主动打开(active open) : 客户发送一个没有数据的SYN segment,
        里面只有一个序列号, 就是三次握手建立以后客户端发送的第一个数据的序号(假设为J)
     3) 服务器必须确认(ACK)序号为J的SYN, 同时发送自己在这次握手后发送的第一个数据的
        序号(假设为K), 这个ACK和SYN都是在一个segment中发送的
     4) 客户端要确认服务器的序号为K的SYN
     5) 因为 2,3,4三步中要有三个segment才能完成连接的建立,所以这个过程叫做三次握手
   + 三次握手图解, 我们可以看到ACK返回的是J+1这是因为SYN本身会占用一个序列号, J是当前
     序列号,那么等连接建立,下次发送的就是J+1了
     #+begin_example
                      client                       server
          socket()      |      SYN(J)                |socket(), bind(), listen()
                        |                            |
       connect() blocks +--------------------------->|accept() blocks
                        |    SYN(K), ACK(J+1)      / |
       connect() returns|<-------------------------/ |
                        |\    ACK(K+1)               |
                        | \------------------------->|accept() returns
                        |                            |read() blocks
                        |                            |
     #+end_example
** TCP Options
   + MSS: 在传输SYN的同时,发送自己的最大segment的大小(Maximum Segment Size)
   + Windows scale: TCP向对方展示的最大窗口数目为65535(相应的头部只有16bit), 但是
     现在的网络速度要远远大于这个数目, 所以需要一个新的参数Windows scale来成倍扩展
     窗口大小. scale是0到14,表示窗口数目左移多少位最大窗口数目现在是1GB(65535*2^14)
   + Windows scale是一个新的选项,老的TCP实现不支持,所以只有client发送了这个选项,
     并且对方server回应了这个选项,我们才能使用. 同样的,server端只有在client发给了
     你这个选项,你才能回应这个选择.
   + Timestamp: 这个选项对于高速传输时可能产生的数据破坏修复(比如迟到的segment,重复的
     segment)很有意义.
** TCP Connection Termination
   + 建立一个连接需要三次握手, 终止一个连接则需要四次挥手:
     1) 某个应用(服务器端或者客户端都可以, 全双工嘛,两边都一样)首先调用close, 我们称之为
        主动关闭(active close). 这边的TCP主动发送一个FIN segment,表示自己传完了
     2) 接受到FIN的对端执行被动关闭(passive close), 这个FIN会被TCP确认(发送一个ACK)
        同时还会把收到FIN的消息(在当前所有数据之后,加上EOF的方式)传送给上层应用程序
     3) 过了一段时间以后,刚才接受FIN的端,也没有啥东西可传了,就会发送自己的FIN给对方
     4) 对方TCP接受到这个最后的FIN之后,也会发送一个ACK给对方确认的.
   + 四次挥手只是"最多四次", 有些情况下用不了四次:
     - 上面的1FIN可能随着数据一块发过去
     - 上面的2ACK,3FIN可能会在一个segment发过来
     - 上面2和3之间, 被动关闭的那一端还是可以传数据给主动关闭那一端的,只是反过来不行了,
       这个叫做半关闭(half close)
   + TCP四次挥手图解(close()可以释放FIN,同时exit或者非正常中断也会发送)
     #+begin_example
                      client                       server

                        |    FIN(M)                  |
             close()    +--------------------------->|read() return 0 (eof)
                        |    ACK(M+1)              / |
       connect() returns|<-------------------------/ |
                                  ........

                        |    FIN(N)                  |
                        |<---------------------------+close()
                        |\    ACK(N+1)               |
                        | \------------------------->|
                        |                            |
                        |                            |

     #+end_example
